#pragma config( Sensor, port5,  PenEndPos, sensorVexIQ_Touch                )
#pragma config( Motor,  motor2, PenZ,      tmotorVexIQ, PIDControl, encoder )
#pragma config( Motor,  motor3, RotateY,   tmotorVexIQ, PIDControl, encoder )
#pragma config( Motor,  motor4, RotateX,   tmotorVexIQ, PIDControl, encoder )
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//---------------------------------------------------------------------------------------------------------------------
//  BallPainter.v1.c                Written by Andreas Dreier
//                                             andreas@dreier-privat.de
//
//  VEX-IQ-Brain:
//
//    Port 2: Motor Z-Axis (lift pen up/down)
//    Port 3: Motor Y-Axis (move pen left/right)
//    Port 4: Motor X-Axis (rotating ball)
//    Port 5: Touch sensor (detect end position for Y-Axis)
//
//  More information you can find here:  http://www.dreier-privat.de/vex/ballpainter/ballpainter.html
//
//---------------------------------------------------------------------------------------------------------------------

#define WHITE    false
#define BLACK    true

#define PEN_UP   false
#define PEN_DOWN true

//---------------------------------------------------------------------------------------------------------------------
//  Define the available patterns and groups
//---------------------------------------------------------------------------------------------------------------------

char    dialog_patterns[4][26] =
        {
           // Group 1: Upper case patterns
           { 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z' },

           // Group 2: Lower case patterns
           { 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z' },

           // Group 3: Number patterns
           { '1','2','3','4','5','6','7','8','9','0', 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0  },

           // Group 4: Special patterns
           { ' ','_','+','-','*','/','.',':',',',';','@','!','?','$','%','&','(',')','{','}','[',']','^','~','"','#' }
        };

int     dialog_length[4] =
        {
            26,   // Group 1: 26 patterns
            26,   // Group 2: 26 patterns
            10,   // Group 3: 10 patterns
            26    // Group 4: 26 patterns
        };

int     dialog_select[4] =
        {
            0,    // Group 1: Upper case patterns
            0,    // Group 2: lower case patterns
            0,    // Group 3: Number patterns
            0     // Group 4: Special patterns
        };

int     dialog_group = 0;

int     scaleX = -250;
int     scaleY =  200;

string  input_text       = "____________________";

char    input[22] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
int     input_max = 21;
int     input_len = 0;

char    *pattern;
int     pattern_length;

int     move_empty_x = 0;
int     move_empty_y = 0;

bool    pen_pos = PEN_UP;

//---------------------------------------------------------------------------------------------------------------------
// Give back the drawing instructions (pattern) and length of pattern (pattern_length)
// for a given letter c
//---------------------------------------------------------------------------------------------------------------------

void GetPattern( char c )
{
     switch( c )
     {
          case '\001': // Heloween pumpkin
                       pattern = "U66D6666669988888774448921444112222233U887D33666699442484424844U899D9443U66D1667U66D9443U333332\000";
                       break;
          case '\002': pattern = "D88889993332222444444U6666666\000";
                       break;
          case '\003': pattern = "8D8624U36\000";
                       break;
          case '\004': // Japanize name of grand master Yoshihito Isogawa :-)
                       pattern = "D666666448884444U888D666644222222U9996D666644882222U99988D22U98D22U98D222222U988D6666448U74D682286682286U1111D992317U9966D199122U99D66U14D666U23\000";
                       break;
          case ' '   : pattern = "66666\000";
                       break;
          case '!'   : pattern = "888899D2222U22DU666\000";
                       break;
          case '"'   : pattern = "888889D2U6D8U333222\000";
                       break;
          case '#'   : pattern = "6D888888U66D222222U98D4444U88D6666U2223\000";
                       break;
          case '$'   : pattern = "8D36698744789663U77D22222222U966\000";
                       break;
          case '%'   : pattern = "D899998U444D1397U33322D1793U3\000";
                       break;
          case '&'   : pattern = "6699D114789987123333U6\000";
                       break;
          case '\''  : pattern = "888899D2U33322\000";
                       break;
          case '('   : pattern = "666D47888896U332222\000";
                       break;
          case ')'   : pattern = "6D69888874U333322\000";
                       break;
          case '*'   : pattern = "89D99U22D77U2D66U1D88U3332\000";
                       break;
          case '+'   : pattern = "99D882466U332\000";
                       break;
          case ','   : pattern = "96D21U9666\000";
                       break;
          case '-'   : pattern = "889D66U332\000";
                       break;
          case '.'   : pattern = "66DU666\000";
                       break;
          case '/'   : pattern = "D899998U222223\000";
                       break;
          case '0'   : pattern = "8D88889663222214479999U32222\000";
                       break;
          case '1'   : pattern = "8889D99222222U66\000";
                       break;
          case '2'   : pattern = "88888D9663211116666U6\000";
                       break;
          case '3'   : pattern = "88888D96632146321447U36666\000";
                       break;
          case '4'   : pattern = "666D88888811126666U32\000";
                       break;
          case '5'   : pattern = "8D3669874448886666U322222\000";
                       break;
          case '6'   : pattern = "88D96632144788889663U32222\000";
                       break;
          case '7'   : pattern = "888888D6666211222U666\000";
                       break;
          case '8'   : pattern = "8D89669874412366321447U36666\000";
                       break;
          case '9'   : pattern = "8D36698888744123669U3222\000";
                       break;
          case ':'   : pattern = "8899DU22DU336\000";
                       break;
          case ';'   : pattern = "998DU22D21U9666\000";
                       break;
          case '<'   : pattern = "669D7799U33222\000";
                       break;
          case '='   : pattern = "89D66U8D44U3336\000";
                       break;
          case '>'   : pattern = "9D9977U33332\000";
                       break;
          case '?'   : pattern = "8888D896632112U2DU666\000";
                       break;
          case '@'   : pattern = "99D79316987441223666U3\000";
                       break;
          case 'A'   : pattern = "D888889663222228884444U33366\000";
                       break;
          case 'B'   : pattern = "D888888666321444666321444U66666\000";
                       break;
          case 'C'   : pattern = "6669D144788889663U22223\000";
                       break;
          case 'D'   : pattern = "D888888666322221444U66666\000";
                       break;
          case 'E'   : pattern = "6666D444488866448886666U222223\000";
                       break;
          case 'F'   : pattern = "D88866448886666U222223\000";
                       break;
          case 'G'   : pattern = "899D6622144788889663U32222\000";
                       break;
          case 'H'   : pattern = "D8888882226666888222222U6\000";
                       break;
          case 'I'   : pattern = "6D664888888466U222233\000";
                       break;
          case 'J'   : pattern = "8D3669888884444U333332\000";
                       break;
          case 'K'   : pattern = "D88888822229999111333U6\000";
                       break;
          case 'L'   : pattern = "888888D2222226666U6\000";
                       break;
          case 'M'   : pattern = "D8888883399222222U6\000";
                       break;
          case 'N'   : pattern = "D888888233332888888U222223\000";
                       break;
          case 'O'   : pattern = "8D8888966322221447U36666\000";
                       break;
          case 'P'   : pattern = "D888888666321444U33366\000";
                       break;
          case 'Q'   : pattern = "8D888896632221147U96D33U6\000";
                       break;
          case 'R'   : pattern = "D8888886663214446333U6\000";
                       break;
          case 'S'   : pattern = "8D36698744789663U32222\000";
                       break;
          case 'T'   : pattern = "66D888888446666U222223\000";
                       break;
          case 'U'   : pattern = "888888D22222366988888U222223\000";
                       break;
          case 'V'   : pattern = "888888D222233998888U322222\000";
                       break;
          case 'W'   : pattern = "888888D2222229933888888U222223\000";
                       break;
          case 'X'   : pattern = "D899998U4444D233332U6\000";
                       break;
          case 'Y'   : pattern = "888888D223322889988U222223\000";
                       break;
          case 'Z'   : pattern = "888888D66662111126666U6\000";
                       break;
          case '['   : pattern = "666D4488888866U332222\000";
                       break;
          case '\\'  : pattern = "888888D233332U6\000";
                       break;
          case ']'   : pattern = "6D6688888844U333322\000";
                       break;
          case '^'   : pattern = "88889D93U33222\000";
                       break;
          case '_'   : pattern = "D6666U6\000";
                       break;
          case '`'   : pattern = "888889D3U33322\000";
                       break;
          case 'a'   : pattern = "669D147889662222U6\000";
                       break;
          case 'b'   : pattern = "D8889632214788888U333322\000";
                       break;
          case 'c'   : pattern = "999D74122369U3\000";
                       break;
          case 'd'   : pattern = "669D14788963888222222U6\000";
                       break;
          case 'e'   : pattern = "88D666874122366U6\000";
                       break;
          case 'f'   : pattern = "D88888963U114D66U332\000";
                       break;
          case 'g'   : pattern = "2D66988874122369U3\000";
                       break;
          case 'h'   : pattern = "D88888822663222U6\000";
                       break;
          case 'i'   : pattern = "D8888U88DU322222\000";
                       break;
          case 'j'   : pattern = "2D98888U88DU322222\000";
                       break;
          case 'k'   : pattern = "D888888U336D117333U6\000";
                       break;
          case 'l'   : pattern = "888888D222223U6\000";
                       break;
          case 'm'   : pattern = "D888829322288893222U6\000";
                       break;
          case 'n'   : pattern = "D88882963222U6\000";
                       break;
          case 'o'   : pattern = "669D1478896322U3\000";
                       break;
          case 'p'   : pattern = "2D8888866322144U6666\000";
                       break;
          case 'q'   : pattern = "666D4478896622222U9\000";
                       break;
          case 'r'   : pattern = "D8888296U3222\000";
                       break;
          case 's'   : pattern = "8D369747963U322\000";
                       break;
          case 't'   : pattern = "6D88888822466U3222\000";
                       break;
          case 'u'   : pattern = "8888D2223698882222U6\000";
                       break;
          case 'v'   : pattern = "8888D22339988U3222\000";
                       break;
          case 'w'   : pattern = "8888D222299338888U2223\000";
                       break;
          case 'x'   : pattern = "D9999U4444D3333U6\000";
                       break;
          case 'y'   : pattern = "2D6698888222147888U3333\000";
                       break;
          case 'z'   : pattern = "8888D6661112666U6\000";
                       break;
          case '{'   : pattern = "66D787989U322222\000";
                       break;
          case '|'   : pattern = "D888888U222223\000";
                       break;
          case '}'   : pattern = "D989787U333222\000";
                       break;
          case '~'   : pattern = "88888D939U322222\000";
                       break;
          case '?'   : pattern = "9666D1478888963U1D444U2D666U332\000";
                       break;
          case '¦'   : pattern = "D66666666668444444444486666666666844444444448666666666684444444444866666666668444444444486666666666U32222222\000";
                       break;
          case '§'   : pattern = "D66666666668444444444486666666666844444444448666666666684444444444866666666668444444444486666666666U32222222\000";
                       break;
          case '®'   : pattern = "8D8888966322221447U9D698742222863U36\000";
                       break;
          case '³'   : pattern = "888888D624624U3322\000";
                       break;
          default  : pattern = "\0";
     }

     pattern_length = 0;
     while( pattern[pattern_length] != '\0' )
            pattern_length++;
}


//---------------------------------------------------------------------------------------------------------------------
//  Draw the pattern defined in ascii with the given size at the given position bx/by. With optional parameters bold
//  the pattern will be painted bold and the last optional parameter defined the color to be used (default is white).
//---------------------------------------------------------------------------------------------------------------------

void displayPattern( char ascii, int size, int &bx, int &by, bool bold=true, bool col=WHITE )
{
     int c;
     int x1;
     int x2;
     int y1;
     int y2;
     int z;

     x1=bx;
     y1=by;
     z=0;

     GetPattern( ascii );
     c=0;

     while( c < pattern_length )
     {
            x2=x1;
            y2=y1;
            switch( pattern[c] )
            {
                  case '1' : while( pattern[c] == '1' )
                             {
                                    x2=x2-size;
                                    y2=y2-size;
                                    c++;
                             }
                             break;

                  case '2' : while( pattern[c] == '2' )
                             {
                                    y2=y2-size;
                                    c++;
                             }
                             break;

                  case '3' : while( pattern[c] == '3' )
                             {
                                    x2=x2+size;
                                    y2=y2-size;
                                    c++;
                             }
                             break;

                  case '4' : while( pattern[c] == '4' )
                             {
                                    x2=x2-size;
                                    c++;
                             }
                             break;

                  case '6' : while( pattern[c] == '6' )
                             {
                                    x2=x2+size;
                                    c++;
                             }
                             break;

                  case '7' : while( pattern[c] == '7' )
                             {
                                    x2=x2-size;
                                    y2=y2+size;
                                    c++;
                             }
                             break;

                  case '8' : while( pattern[c] == '8' )
                             {
                                    y2=y2+size;
                                    c++;
                             }
                             break;

                  case '9' : while( pattern[c] == '9' )
                             {
                                    x2=x2+size;
                                    y2=y2+size;
                                    c++;
                             }
                             break;

                  case 'U' : z=0;
                             c++;
                             break;

                  case 'D' : z=1;
                             c++;
                             break;

                  default  : c++;
            }

            if( z )
            {
                if( col == BLACK )
                {
                    drawLine( x1, y1, x2, y2  );

                    if( bold )
                    {
                        drawLine( x1,   y1-1, x2,   y2-1 );
                        drawLine( x1-1, y1,   x2-1, y2   );
                        drawLine( x1,   y1+1, x2,   y2+1 );
                        drawLine( x1+1, y1,   x2+1, y2   );
                    }
                }
                else
                {
                    eraseLine( x1, y1, x2, y2 );

                    if( bold )
                    {
                        eraseLine( x1,   y1-1, x2,   y2-1 );
                        eraseLine( x1-1, y1,   x2-1, y2   );
                        eraseLine( x1,   y1+1, x2,   y2+1 );
                        eraseLine( x1+1, y1,   x2+1, y2   );
                    }
                }
            }

            x1=x2;
            y1=y2;
     }

     //--------------------------------------------------------------------
     // give the end position back in bx/by
     //--------------------------------------------------------------------

     bx = x1;
     by = y1;
}


//---------------------------------------------------------------------------------------------------------------------
//  Display given string t at given position x/y with defined size. Last parameter defined if the string will be
//  painted bold on screen or not.
//---------------------------------------------------------------------------------------------------------------------

void displayPatternString( int x, int y, int size, char *t, bool bold )
{
     int i;

     for( i=0; i<strlen( t ); i++ )
     {
          displayPattern( t[i], size, x,y, bold, true );
          x=x+1;
          if( bold )
              x=x+1;
     }
}


//---------------------------------------------------------------------------------------------------------------------
//  Load a new ball and wait until confirmation by pressing F-Up
//---------------------------------------------------------------------------------------------------------------------

void LoadNewBall()
{
    eraseDisplay();

    displayPatternString( 1,30, 2, "Load new ball", true );
    displayPatternString( 2,20, 1, "Please insert a new ball", false );
    displayPatternString( 2,12, 1, "and fix it between holder.", false );
    displayPatternString( 2, 2, 1, "Confirm by pressing F-Up", false );

    while( ! vexRT[ BtnFUp ] )
           sleep( 50 );

    eraseDisplay();
}


//---------------------------------------------------------------------------------------------------------------------
//  Initialize the bot
//  0) Display initialization progress
//  1) Lift the pen up and define zero position (z-axis)
//  2) Find the left end position (y-axis)
//  3) Bring to initial position for loading the ball
//---------------------------------------------------------------------------------------------------------------------

void InitBot()
{
    //--------------------------------------------------------------------
    //  0) Display initialization progress
    //--------------------------------------------------------------------

    eraseDisplay();
    displayPatternString( 1,30, 2, "Initialize", true );

    //--------------------------------------------------------------------
    //  1) Lift the pen up and define zero position (z-axis)
    //--------------------------------------------------------------------

    displayPatternString( 2,20, 1, "1) Init z-axis", false );

    setMotorSpeed( PenZ,  50 );
    delay( 300 );
    setMotorSpeed( PenZ,  0 );
    delay( 100 );
    resetMotorEncoder( PenZ );
    setMotorTarget( PenZ, -5, 50 );
    delay( 200 );
    resetMotorEncoder( PenZ );

    //--------------------------------------------------------------------
    //  2) Find the left end position (y-axis)
    //--------------------------------------------------------------------

    displayPatternString( 2,11, 1, "2) Init y-axis", false );

    //--------------------------------------------------------------------
    //  2a) Already touched the Bumper?
    //--------------------------------------------------------------------

    if( getBumperValue(PenEndPos))
    {
        setMotorSpeed( RotateY, 50 );
        while( getBumperValue( PenEndPos ) )
               sleep( 100 );
        setMotorSpeed( RotateY, 0 );
    }

    //--------------------------------------------------------------------
    //  2b) Now go forward until bumper reached
    //--------------------------------------------------------------------

    setMotorSpeed( RotateY,-50 );
    while( ! getBumperValue( PenEndPos ) )
           sleep( 10 );
    setMotorSpeed( RotateY, 0 );
    sleep( 100 );
    resetMotorEncoder( RotateY );
    sleep( 100 );

    //--------------------------------------------------------------------
    //  2c) go to middle position and reset the zero-Positon for Y-Axis
    //--------------------------------------------------------------------

    setMotorTarget( RotateY, 800, 100 );
    waitUntilMotorStop( RotateY );
    resetMotorEncoder( RotateY );

    //--------------------------------------------------------------------
    // 3) Bring to base position for loading a ball
    //--------------------------------------------------------------------

    displayPatternString( 2,2, 1, "3) Pen in start position", false );

    setMotorTarget( RotateY, -500,100 );
    waitUntilMotorStop( RotateY );
}


//---------------------------------------------------------------------------------------------------------------------
//  Make a move of the pen based on x-axle and y-axle.
//---------------------------------------------------------------------------------------------------------------------

void PenMove( int dx, int dy )
{
    int px;
    int py;

    px = getMotorEncoder( RotateX );
    py = getMotorEncoder( RotateY );

    setMotorTarget( RotateX, px+dx, 50 );
    setMotorTarget( RotateY, py+dy, 50 );

    waitUntilMotorStop( RotateX );
    waitUntilMotorStop( RotateY );
}


//---------------------------------------------------------------------------------------------------------------------
//  Do Empty move
//---------------------------------------------------------------------------------------------------------------------

void DoEmptyMove()
{
    PenMove( move_empty_x, move_empty_y );
    move_empty_x = 0;
    move_empty_y = 0;
}


//---------------------------------------------------------------------------------------------------------------------
//  Depending on position of Pen (up/down) it's a move or only calculation for empty move
//---------------------------------------------------------------------------------------------------------------------

void MoveOrDraw( int dx, int dy )
{
	   if( pen_pos == PEN_DOWN )
	       PenMove( dx, dy );
	   else {
	       move_empty_x = move_empty_x + dx;
	       move_empty_y = move_empty_y + dy;
	   }
}


//---------------------------------------------------------------------------------------------------------------------
//  Lift the pen up (z-axle)
//---------------------------------------------------------------------------------------------------------------------

void PenUp()
{
	  pen_pos = false;
    setMotorTarget( PenZ, 0, 50 );
    waitUntilMotorStop( PenZ );
}


//---------------------------------------------------------------------------------------------------------------------
//  Move the pen down on the ball (z-axle)
//---------------------------------------------------------------------------------------------------------------------

void PenDown()
{
    DoEmptyMove();
	  pen_pos = PEN_DOWN;

    setMotorTarget( PenZ, -30, 20 );
    waitUntilMotorStop( PenZ );
}


//---------------------------------------------------------------------------------------------------------------------
// Plot text on given position x/y with given size (size) in given direction (direction).
//---------------------------------------------------------------------------------------------------------------------

void DrawInputOnBall( int size, char *t )
{
     int p;
     int c;
     int dx;
     int dy;
     int px;
     int py;
     int n;

     eraseDisplay();
     displayPatternString( 1,30, 2, "Draw on ball", true );

     p=0;
     while( t[p] != '\0' )
     {

          fillRect( 0,0,30,26 );
          px = 8;
          py = 5;
          displayPattern( t[p],3,px,py,true,false );

          GetPattern( t[p] );
          // variable pattern contains now the drawing commands!

          c=0;
          while( c < pattern_length )
          {
               dx = 0;
               dy = 0;
               n  = 0;

               switch( pattern[c] )
               {
                  case '1' : while( pattern[c] == '1' )
                             {
                                 n++;
                                 c++;
                             }

                             MoveOrDraw( n * ( -scaleX ),
                                         n * ( -scaleY ) );
                             break;

                  case '2' : while( pattern[c] == '2' )
                             {
                                 n++;
                                 c++;
                             }

                             MoveOrDraw( 0, n * (-scaleY ) );

                             break;

                  case '3' : while( pattern[c] == '3' )
                             {
                                 n++;
                                 c++;
                             }

                             MoveOrDraw( n * (  scaleX ),
                                         n * ( -scaleY ) );

                             break;

                  case '4' : while( pattern[c] == '4' )
                             {
                                 n++;
                                 c++;
                             }

                             MoveOrDraw( n * ( -scaleX ),
                                         0                );

                             break;

                  case '6' : while( pattern[c] == '6' )
                             {
                                 n++;
                                 c++;
                             }

                             MoveOrDraw( n * (  scaleX ),
                                          0               );

                             break;

                  case '7' : while( pattern[c] == '7' )
                             {
                                 n++;
                                 c++;
                             }

                             MoveOrDraw( n * ( -scaleX ),
                                         n * (  scaleY ) );

                             break;

                  case '8' : while( pattern[c] == '8' )
                             {
                                 n++;
                                 c++;
                             }

                             MoveOrDraw( 0,
                                         n * (  scaleY ) );

                             break;

                  case '9' : while( pattern[c] == '9' )
                             {
                                 n++;
                                 c++;
                             }

                             MoveOrDraw( n * (  scaleX ),
                                         n * (  scaleY ) );

                             break;

                  case 'U' : while( pattern[c] == 'U' )
                                  c++;
                             PenUp();
                             break;

                  case 'D' : while( pattern[c] == 'D' )
                                  c++;
                             PenDown();
                             break;

                  default  : c++;
              }
         }

         p++;
    }

    // Finish the last empty move:

    DoEmptyMove();
}


//---------------------------------------------------------------------------------------------------------------------
//  Display the text which was entered by the user
//---------------------------------------------------------------------------------------------------------------------

void DisplayInput( )
{
     int i;
     int posx;
     int posy;

     posy = 37;
     eraseRect( 0,posy-1,127,posy+7 );
     for( i=0; i<input_max; i++ )
     {
          posx = 1 + i*6;
          displayPattern( input[i],1,posx,posy,false,true );
     }
}


//---------------------------------------------------------------------------------------------------------------------
//  Draw the big pattern which is currently selected by the user
//---------------------------------------------------------------------------------------------------------------------

void UpdateBigPattern()
{
     int ascii;
     int posx;
     int posy;

     ascii = dialog_patterns[ dialog_group ][ dialog_select[dialog_group] ];
     posx  =  56;
     posy  =  7;

     fillRect( 49,0,79,35 );
     displayPattern( ascii,4,posx,posy,true,false );
}


//---------------------------------------------------------------------------------------------------------------------
//  Update the row of possible patterns of the current pattern group
//---------------------------------------------------------------------------------------------------------------------

void UpdatePatternRow( int row )
{
     int  x;
     int  y;
     int  c;
     int  i;
     int  n;
     bool b;

     b = ( row == dialog_group );
     y = 27 - 9*row;

     if( b )
     {
         fillRect(  0, y-2,  48, y+7 );
         fillRect( 80, y-2, 127, y+7 );
     }
     else
     {
         eraseRect(  0, y-2,  48, y+7 );
         eraseRect( 80, y-2, 127, y+7 );
     }

     for( i=0; i<6; i++ )
     {
          n = dialog_select[ row ]+i+1;
          if( n >= dialog_length[ row ] ) n = n - dialog_length[ row ];
          c = dialog_patterns[ row ][ n ];
          x = 84 + 7*i;
          displayPattern( c, 1, x,y, false, ! b );

          n = dialog_select[ row ]-i-1;
          if( n < 0                    ) n = n + dialog_length[ row ];
          c = dialog_patterns[ row ][ n ];
          x = 46 - 7 - 7*i;
          displayPattern( c, 1, x,y, false, ! b );
     }
}


//---------------------------------------------------------------------------------------------------------------------
//  Let the user enter a new text which should be plotted on the ball
//---------------------------------------------------------------------------------------------------------------------

void EnterInput()
{
     char   ascii_text[22]   = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
     int    control_pattern;
     int    control_group;
     int    old_group;
     int    counter;
     int    x;
     int    posx;
     int    posy;


     eraseDisplay();
     drawLine(0,35,127,35 );

     UpdateBigPattern();

     UpdatePatternRow( 0 );
     UpdatePatternRow( 1 );
     UpdatePatternRow( 2 );
     UpdatePatternRow( 3 );

     for( x=0; x<input_max; x++ )
          input[x] = '\0';
     input[input_max]='\0';
     input_len = 0;

     DisplayInput();

     counter = 0;
     while( ! vexRT[ BtnRUp] )
     {
          if( counter < 150 )
              counter++;
          {
              posx = 6*input_len;
              posy = 36;
              for( x=0; x<7; x++ )
                   invertLine( posx+x,posy,posx+x,posy+8 );
              counter = 0;
          }

          //---------------------------------------------------------------------------
          // Control group of patterns

          control_group   = vexRT[ ChD ];

          if( control_group < -50 )
          {
              old_group = dialog_group;

              if( dialog_group < 3 )
                  dialog_group++;
              else
                  dialog_group=0;

              UpdateBigPattern();
              UpdatePatternRow( old_group );
              UpdatePatternRow( dialog_group );

              while( vexRT[ ChD] < -50 )
                     delay( 20 );
          }

          if( control_group > 50 )
          {
              old_group = dialog_group;

              if( dialog_group > 0 )
                  dialog_group--;
              else
                  dialog_group=3;

              UpdateBigPattern();
              UpdatePatternRow( old_group );
              UpdatePatternRow( dialog_group );

              while( vexRT[ ChD] > 50 )
                     delay( 20 );
          }

          //---------------------------------------------------------------------------
          // Control pattern selection

          control_pattern = vexRT[ ChC ];

          if( control_pattern < -50 )
          {
              if( dialog_select[ dialog_group ] > 0 )
                  dialog_select[ dialog_group ]--;
              else
                  dialog_select[ dialog_group ] = dialog_length[ dialog_group ]-1;

              UpdateBigPattern();
              UpdatePatternRow( dialog_group );

              sleep( 100 );
          }

          if( control_pattern > 50 )
          {
              if( dialog_select[ dialog_group ] < dialog_length[ dialog_group ]-1 )
                  dialog_select[ dialog_group ]++;
              else
                  dialog_select[ dialog_group ] = 0;

              UpdateBigPattern();
              UpdatePatternRow( dialog_group );

              sleep( 100 );
          }

          //---------------------------------------------------------------------------
          // Add selected pattern to the string

          if( vexRT[ BtnEUp ] )
          {
              input[input_len] = dialog_patterns[ dialog_group ][ dialog_select[ dialog_group ] ];

              if( input_len < input_max-1 )
                  input_len++;

              // displayStringAt( 0,43, input );
              DisplayInput( );

              while( vexRT[ BtnEUp ] )
                     sleep( 50 );
          }

          //---------------------------------------------------------------------------
          // Remove last pattern from string

          if( vexRT[BtnEDown] )
          {
              if( ( input_len          == input_max-1 ) &&
                  ( input[input_max-1] != '\0'         )       )
                  input[input_max-1] = '\0';
              else
              {
                  if( input_len > 0 )
                      input_len--;

                  input[ input_len ] = '\0';
              }

              DisplayInput( );

              while( vexRT[ BtnEDown ] )
                     sleep( 50 );
          }

          sleep( 20 );
     }


     stringFromChars( input_text,input );
}


//---------------------------------------------------------------------------------------------------------------------
//  Main program
//---------------------------------------------------------------------------------------------------------------------

task main()
{
    InitBot();

    while( 1 )
    {
       LoadNewBall();
       EnterInput();
       DrawInputOnBall( 1,input_text );
    }
}

//---------------------------------------------------------------------------------------------------------------------
//  BallPainter.v1.c     ---     end of file
//---------------------------------------------------------------------------------------------------------------------
